---
title: "Create your own categorical class: ordinal"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
library(categorical)
```
We want to create a new vector class for ordinal data. We use a standard "categorical" class, but add a standardised alternative for the "rank" of a response. We start with a function that creates a new ordinal vector. it should

- make sure the inputs make sense
- create a categorical subclass that we call "categorical_ordinal"

```{r}

ordinal <- function(x, levels, ranks){
  # make sure inputs make sense:
  stopifnot({
    is.vector(x)
    is.vector(levels)
    is.integer(ranks)
    all(unique(x) %in% levels)
    length(levels)==length(ranks)
    })
  # create categorical subclass:
  categorical(x,
              levels = levels,
              alternatives_internal = list(rank = ranks),
              class = "categorical_ordinal"
              )
}

test_vec <- ordinal(x = c("C","A","A","B","C"),levels = c("A","B","C"), ranks =  1:3)
print(test_vec)
```

A custom format function to show the rank when printing:
```{r}
format.categorical_ordinal<-function(x, ...){
  rank <- alternate(x,alternative = 'rank',internal = T)
  paste0("#", rank, "-", x)
}

format.categorical_ordinal(test_vec)
print(test_vec)
```

```{r}
vec_proxy_compare.categorical_ordinal<-function(x){
  alternate(x,"rank",T)
}


class(test_vec)
```


Now we use the functionality of the underlying vctrs package to define how ordinal vectors get converted to other types, especially numeric / double. First we need to create the standard boilerplates according to the `vctrs` package:

```{r}

#' BOILERPLATES
#'
#' Based on browseVignettes('vctrs')
#'
#' start with the boilerplate for vec_ptype2()
#' this is just so later we can write vec_ptype2.categorical_ordinal.OTHERCLASS
#' to define how these two classes should be coerced together
vec_ptype2.categorical_ordinal <- function(x, y, ...) UseMethod("vec_ptype2.categorical_ordinal", y)

#' default common type for categorical_ordinal
vec_ptype2.categorical_ordinal.default <- function(x, y, ..., x_arg = "x", y_arg = "y") {
  vctrs::vec_default_ptype2(x, y, x_arg = x_arg, y_arg = y_arg)
}

#' cast categorical_ordinal vectors
vec_cast.categorical_ordinal <- function(x, to, ...) UseMethod("vec_cast.categorical_ordinal")

#' cast categorical default
vec_cast.categorical_ordinal.default <- function(x, to, ...) vctrs::vec_default_cast(x, to)


```
Now define the conversion to numeric specifically:

```{r}

# how does the common type of an ordinal and a numeric vector look like? 
vec_ptype2.double.categorical_ordinal <- function(x,y, ..., x_arg = "x", y_arg = "y"){
  alternate(x, "rank", internal = T)
}
# how to cast categorical to numeric?
vec_cast.double.categorical_ordinal <- function(x, to, ...){
  alternate(x, "rank", internal = T)
}
# how does the common type of a numeric and an ordinal vector look like?
vec_ptype2.categorical_ordinal.double <- function(x,y, ..., x_arg = "x", y_arg = "y"){
  levels<-unique(x)
  ordinal(x, levels = levels,ranks = levels)
}
# how to cast numeric to categorical?
vec_cast.categorical_ordinal.double <- function(x, to, ...){
  levels<-unique(x)
  ordinal(x, levels = levels, ranks = levels)
}

```

And now...:
```{r}
test_vec
as.numeric(test_vec)
test_vec > 2
```

the alternative "rank" as the numeric proxy for comparisons (see `browseVignettes("vctrs")`: 
```{r}
vec_proxy_compare.categorical_ordinal<-function(x,...){
  alternate(x,alternative = 'ranks',internal = T) 
  }
```

Now we can treat our ordinal vector like a numeric one:


```{r}
test_vec < 1.0

```

