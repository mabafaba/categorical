% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select_multiple_coersion.R
\name{vec_ptype2.cat_select_multiple}
\alias{vec_ptype2.cat_select_multiple}
\title{When the change happens implicitly (e.g in c()) we call it coercion
ec_ptype2(x, y) defines possible set of coercions.
It returns a prototype if x and y can be safely coerced to the same prototype;
otherwise it returns an error.
The set of automatic coercions is usually quite small
because too many tend to make code harder to reason about
and silently propagate mistakes.
each combo of our class and other classes that can be coerced toghether has
a function that returns just a prototype of the resulting class
start with the boilerplate for vec_ptype2()
this is just so later we can write vec_ptype2.cat_select_multiple.OTHERCLASS
to define how these two classes should be coerced together}
\usage{
vec_ptype2.cat_select_multiple(x, y, ...)
}
\arguments{
\item{x}{vector object}

\item{y}{vector object}

\item{...}{additional arguments}
}
\description{
When the change happens implicitly (e.g in c()) we call it coercion
ec_ptype2(x, y) defines possible set of coercions.
It returns a prototype if x and y can be safely coerced to the same prototype;
otherwise it returns an error.
The set of automatic coercions is usually quite small
because too many tend to make code harder to reason about
and silently propagate mistakes.
each combo of our class and other classes that can be coerced toghether has
a function that returns just a prototype of the resulting class
start with the boilerplate for vec_ptype2()
this is just so later we can write vec_ptype2.cat_select_multiple.OTHERCLASS
to define how these two classes should be coerced together
}
